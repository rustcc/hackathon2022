这一章主要讲一些可能用到的调试技巧。

### 死锁调试

本项目最终的目标是线程安全的，并且为了追求高性能，不会简单地加大锁。所以死锁是一个很常见的问题。同时由于`rustfs`中存在多种线程，包括脏页异步回写线程，前台工作线程，以及可能添加的目录树回收线程等，导致死锁的原因很难被发现。

`rustfs`提供了一个调试死锁的基础设施，来源于我开发时遇到的真实问题：线程由于死锁原因卡住了，我们不知道是哪个线程拿着锁不放。

我们可以这样调试：

之前是这样获取锁的，假设现在一个线程卡在这里拿不到`mutex`。

```rust
let mut lk = mutex.lock();
```

我们可以这样修改获取`mutex`的每个地方，这样就可以知道是哪个线程卡住了。

```rust
let mut lk = mutex.lock().defer_mut( | _ | set_flag(0));
set_flag(1);
```

原理是这样的：上面的代码会在拿到锁之后把`flag`设置为`1`，释放锁之前把`flag`设置为`0`。每个获取这个锁的地方设置的`flag`不同。在线程卡住时打印`flag`的值，可以根据`flag`
的值知道是哪个线程没有释放这个锁导致死锁，从而找到死锁的原因。

这个基础设施的实现在`src\utils\defer_guard.rs`中。

### 打印日志

`rustfs`引入了日志门面库`log`和日志库`env_logger`，可以通过环境变量`RUST_LOG`来控制日志的输出，使用示例参见`tests/Makfile`。

值得注意的是如果编写了额外的单元测试，并且想通过日志调试，需要在每个测试的开头添加`env_logger::init();`，否则日志不会输出。